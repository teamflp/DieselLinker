use diesel::prelude::*;
use diesel::sqlite::SqliteConnection;
use diesel_linker::relation;

// In a real project, this would be in `src/schema.rs` and generated by `diesel print-schema`.
mod schema {
    diesel::table! {
        users (id) {
            id -> Integer,
            name -> Text,
        }
    }

    diesel::table! {
        posts (id) {
            id -> Integer,
            user_id -> Integer,
            title -> Text,
        }
    }

    diesel::joinable!(posts -> users (user_id));
    diesel::allow_tables_to_appear_in_same_query!(users, posts);
}

// In a real project, this would be in `src/models.rs`.
use schema::{users, posts};

#[derive(Queryable, Identifiable, Insertable, Debug, PartialEq)]
#[diesel(table_name = users)]
// Defines a one-to-many relationship to the `Post` model.
// DieselLinker will generate a `get_posts()` method on the `User` struct.
#[relation(model = "Post", relation_type = "one_to_many", backend = "sqlite")]
pub struct User {
    pub id: i32,
    pub name: String,
}

#[derive(Queryable, Identifiable, Insertable, Associations, Debug, PartialEq)]
#[diesel(belongs_to(User), table_name = posts)]
// Defines a many-to-one relationship to the `User` model.
// DieselLinker will generate a `get_user()` method on the `Post` struct.
#[relation(model = "User", fk = "user_id", relation_type = "many_to_one", backend = "sqlite")]
pub struct Post {
    pub id: i32,
    pub user_id: i32,
    pub title: String,
}

fn main() {
    // 1. Establish a connection to an in-memory SQLite database.
    let mut conn = SqliteConnection::establish(":memory:").unwrap();

    // 2. Create the `users` and `posts` tables.
    diesel::sql_query("CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT NOT NULL)").execute(&mut conn).unwrap();
    diesel::sql_query("CREATE TABLE posts (id INTEGER PRIMARY KEY, user_id INTEGER NOT NULL, title TEXT NOT NULL)").execute(&mut conn).unwrap();

    // 3. Insert test data: one user and two posts.
    let new_user = User { id: 1, name: "Ada Lovelace".to_string() };
    diesel::insert_into(users::table).values(&new_user).execute(&mut conn).unwrap();

    let user_posts = vec![
        Post { id: 1, user_id: 1, title: "Notes on the Analytical Engine".to_string() },
        Post { id: 2, user_id: 1, title: "The first computer algorithm".to_string() },
    ];
    diesel::insert_into(posts::table).values(&user_posts).execute(&mut conn).unwrap();

    println!("--- DieselLinker Demonstration ---");

    // 4. Fetch the user from the database.
    let user = users::table.find(1).first::<User>(&mut conn).unwrap();
    println!("\nFound user: {}", user.name);

    // 5. Use the `get_posts()` method generated by DieselLinker.
    //    This method loads all posts associated with the user.
    println!("Fetching user's posts...");
    let posts = user.get_posts(&mut conn).unwrap();

    println!("'{}' has written {} post(s):", user.name, posts.len());
    for post in posts {
        println!("- {}", post.title);

        // We can also go back from the post to its author.
        let author = post.get_user(&mut conn).unwrap();
        assert_eq!(author.name, user.name);
    }
}
